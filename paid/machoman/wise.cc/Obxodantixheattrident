--РїРµСЂРµРјРµРЅРЅС‹Рµ
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

---РіСѓРёС€РєР°
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "Adrenaline Defusal FPS",
    LoadingTitle = "Adrenaline.CC",
    LoadingSubtitle = "by kyoukidevs",
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil,
       FileName = "Adrenaline"
    }
})

local LegitTab = Window:CreateTab("Legit", "mouse")
local RageTab = Window:CreateTab("Rage", "crosshair")
local VisualsTab = Window:CreateTab("Visuals", "eye")
local LocalTab = Window:CreateTab("Local", "user-round")

local silentAimEnabled = false
local silentAimFOV = 100
local silentAimTargetPart = "Head"
local silentAimHitChance = 100
local autoShootEnabled = false
local autoShootDelay = 0.1
local teamCheckEnabled = false
local Raycastwhitelist = RaycastParams.new()

local silentAimFovCircle = Drawing.new("Circle")
silentAimFovCircle.Visible = false
silentAimFovCircle.Thickness = 2
silentAimFovCircle.NumSides = 64
silentAimFovCircle.Radius = silentAimFOV
silentAimFovCircle.Filled = false
silentAimFovCircle.Color = Color3.fromRGB(255, 0, 0)
silentAimFovCircle.Transparency = 1

local silentAimTargetDot = Drawing.new("Circle")
silentAimTargetDot.Visible = false
silentAimTargetDot.Thickness = 2
silentAimTargetDot.NumSides = 12
silentAimTargetDot.Radius = 6
silentAimTargetDot.Filled = true
silentAimTargetDot.Color = Color3.fromRGB(255, 0, 0)
silentAimTargetDot.Transparency = 1

local function CalculateChance(Percentage)
    return math.random(1, 100) <= Percentage
end

local function getCrosshairPosition()
    local camera = workspace.CurrentCamera
    local viewportSize = camera.ViewportSize
    return Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
end

local function IsVisible(targetPart)
    if not LocalPlayer.Character then return false end
    
    local camera = workspace.CurrentCamera
    local origin = camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit
    local distance = (targetPart.Position - origin).Magnitude
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    
    local raycastResult = workspace:Raycast(origin, direction * distance, raycastParams)
    return raycastResult == nil
end

local function getClosestPlayer()
    if not silentAimEnabled then return nil end
    
    local closestTarget = nil
    local closestDistance = silentAimFOV
    local crosshairPos = getCrosshairPosition()
    local camera = workspace.CurrentCamera
    
    for _, targetPlayer in pairs(Players:GetPlayers()) do
        if targetPlayer == LocalPlayer then continue end

    if teamCheckEnabled then
        if targetPlayer.Team == localPlayer.Team and targetPlayer.Team ~= nil then
        continue
        end
    end

        local character = targetPlayer.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local targetPart = character:FindFirstChild(silentAimTargetPart)
        
        if not humanoid or humanoid.Health <= 0 or not targetPart then continue end
        
        local screenPos, onScreen = camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local targetPos = Vector2.new(screenPos.X, screenPos.Y)
        local distance = (crosshairPos - targetPos).Magnitude -- Р—Р”Р•РЎР¬ РР—РњР•РќР•РќРР•
        
        if distance <= closestDistance then
            closestTarget = targetPart
            closestDistance = distance
        end
    end
    
    return closestTarget
end


local function autoShoot()
    while true do
        if autoShootEnabled and silentAimEnabled and silentAimTarget then
            mouse1press()
            wait(0.01)
            mouse1release()
        end
        wait(autoShootDelay)
    end
end

local function injectMouseClick()
    if autoShootEnabled and silentAimEnabled and silentAimTarget then
        local mouseEvent = Instance.new("RemoteEvent")
        mouseEvent.Name = "MouseClickEvent"
        mouseEvent.Parent = game:GetService("ReplicatedStorage")

        if LocalPlayer.Character then
            for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    local fireScript = tool:FindFirstChildWhichIsA("LocalScript")
                    if fireScript then
                        fireScript:FireServer("Fire")
                    end
                end
            end
        end
    end
end

local silentAimTarget = nil
local oldNamecall

oldNamecall = hookmetamethod(game, "__namecall", function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    
    if silentAimEnabled and Method == "Raycast" then
        if CalculateChance(silentAimHitChance) and silentAimTarget and silentAimTarget.Parent then
            local self = Arguments[1]
            if self == workspace then
                local origin = Arguments[2]
                local direction = Arguments[3]

                local newDirection = (silentAimTarget.Position - origin).Unit * direction.Magnitude
                Arguments[3] = newDirection
                
                return oldNamecall(unpack(Arguments))
            end
        end
    end
    
    return oldNamecall(...)
end)

RunService.RenderStepped:Connect(function()
    silentAimFovCircle.Position = getCrosshairPosition()
    silentAimFovCircle.Visible = silentAimEnabled
    silentAimFovCircle.Radius = silentAimFOV

    silentAimTarget = getClosestPlayer()

    if silentAimEnabled and silentAimTarget and silentAimTarget.Parent then
        local camera = workspace.CurrentCamera
        local screenPos, onScreen = camera:WorldToViewportPoint(silentAimTarget.Position)
        if onScreen then
            silentAimTargetDot.Visible = false
            silentAimTargetDot.Position = Vector2.new(screenPos.X, screenPos.Y)
        else
            silentAimTargetDot.Visible = false
        end
    else
        silentAimTargetDot.Visible = false
    end

    if autoShootEnabled and silentAimEnabled and silentAimTarget then
        injectMouseClick()
    end
end)

local SilentAimToggle = RageTab:CreateToggle({
    Name = "Silent Aim",
    CurrentValue = false,
    Flag = "SilentAimToggle",
    Callback = function(Value)
        silentAimEnabled = Value
        print("Silent Aim: " .. (Value and "ON" or "OFF"))
    end,
})

local TeamCheckToggle = RageTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = false,
    Flag = "TeamCheckToggle",
    Callback = function(Value)
      teamCheckEnabled = Value
      print("Team Check: " .. (Value and "On" or "OFF"))
    end,
  })

local AutoShootToggle = RageTab:CreateToggle({
    Name = "Auto Shoot",
    CurrentValue = false,
    Flag = "AutoShootToggle",
    Callback = function(Value)
        autoShootEnabled = Value
        if Value then
            spawn(autoShoot)
        end
        print("Auto Shoot: " .. (Value and "ON" or "OFF"))
    end,
})

local WallbangButton = RageTab:CreateButton({
	Name = "Magic Bullet",
	Callback = function()
for i, freakyassguns in pairs(game:GetService("ReplicatedStorage").Weapons:GetChildren()) do if freakyassguns:IsA("Folder") and (freakyassguns:GetAttribute("Penetration")) then 
freakyassguns:SetAttribute("Penetration", "9e999") 
        end 
    end
end,
})
local BozoButton = RageTab:CreateButton({
	Name = "Bozo Gunmods"
	Callback = function()
for i, freakyassguns in pairs(game:GetService("ReplicatedStorage").Weapons:GetChildren()) do if freakyassguns:IsA("Folder") and (freakyassguns:GetAttribute("Penetration") or freakyassguns:GetAttribute("JumpSpread") or freakyassguns:GetAttribute("LadderSpread") or freakyassguns:GetAttribute("LandSpread") or freakyassguns:GetAttribute("MoveSpread") or freakyassguns:GetAttribute("RecoilX") or freakyassguns:GetAttribute("RecoilY") or freakyassguns:GetAttribute("Spread") or freakyassguns:GetAttribute("CrouchSpread") or freakyassguns:GetAttribute("CrouchRecoveryTime") or freakyassguns:GetAttribute("FireSpread")) then freakyassguns:SetAttribute("Penetration", "9e999") freakyassguns:SetAttribute("JumpSpread", 0) freakyassguns:SetAttribute("LadderSpread", 0) freakyassguns:SetAttribute("LandSpread", 0) freakyassguns:SetAttribute("MoveSpread", 0) freakyassguns:SetAttribute("RecoilX", 0) freakyassguns:SetAttribute("RecoilY", 0) freakyassguns:SetAttribute("Spread", 0) freakyassguns:SetAttribute("CrouchSpread", 0) freakyassguns:SetAttribute("CrouchRecoveryTime", 0) freakyassguns:SetAttribute("FireSpread", 0) freakyassguns:SetAttribute("FireRate", 0.1) freakyassguns:SetAttribute("ClipRefill", 0) freakyassguns:SetAttribute("EquipTime", 0) freakyassguns:SetAttribute("Auto", true) freakyassguns:SetAttribute("Bullets", 1) end end
})

local SilentAimFOVSlider = RageTab:CreateSlider({
    Name = "Silent Aim FOV",
    Range = {50, 300},
    Increment = 10,
    Suffix = "Units",
    CurrentValue = silentAimFOV,
    Flag = "SilentAimFOV",
    Callback = function(Value)
        silentAimFOV = Value
        silentAimFovCircle.Radius = Value
    end,
})

local SilentAimHitChanceSlider = RageTab:CreateSlider({
    Name = "Hit Chance",
    Range = {0, 100},
    Increment = 1,
    Suffix = "%",
    CurrentValue = silentAimHitChance,
    Flag = "SilentAimHitChance",
    Callback = function(Value)
        silentAimHitChance = Value
    end,
})

local AutoShootDelaySlider = RageTab:CreateSlider({
    Name = "Auto Shoot Delay",
    Range = {0.05, 0.5},
    Increment = 0.01,
    Suffix = "sec",
    CurrentValue = autoShootDelay,
    Flag = "AutoShootDelay",
    Callback = function(Value)
        autoShootDelay = Value
    end,
})

local TargetPartDropdown = RageTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart"},
    CurrentOption = silentAimTargetPart,
    Flag = "TargetPartDropdown",
    Callback = function(Option)
        silentAimTargetPart = Option
    end,
})

spawn(autoShoot)


-- rage | hitbox
local hitboxExpanderEnabled = false
local hitboxSize = 1.5
local originalSizes = {}
local hitboxParts = {"Head", "HumanoidRootPart"}

local function updateHitboxes()
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        
        local character = player.Character
        if not character then continue end
        
        for _, partName in pairs(hitboxParts) do
            local part = character:FindFirstChild(partName)
            if part then
                if hitboxExpanderEnabled then
                    if not originalSizes[player.Name..partName] then
                        originalSizes[player.Name..partName] = part.Size
                    end
                    
                    part.Size = originalSizes[player.Name..partName] * hitboxSize
                    part.CanCollide = false
                else
                    if originalSizes[player.Name..partName] then
                        part.Size = originalSizes[player.Name..partName]
                    end
                end
            end
        end
    end
end

local function resetPlayerHitboxes(player)
    for _, partName in pairs(hitboxParts) do
        if originalSizes[player.Name..partName] then
            originalSizes[player.Name..partName] = nil
        end
    end
end

local HitboxExpanderToggle = RageTab:CreateToggle({
    Name = "Hitbox Expander",
    CurrentValue = false,
    Flag = "HitboxExpanderToggle",
    Callback = function(Value)
        hitboxExpanderEnabled = Value
        updateHitboxes()
        print("Hitbox Expander: " .. (Value and "ON" or "OFF"))
    end,
})

local HitboxSizeSlider = RageTab:CreateSlider({
    Name = "Hitbox Size",
    Range = {1.0, 10.0},
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = hitboxSize,
    Flag = "HitboxSizeSlider",
    Callback = function(Value)
        hitboxSize = Value
        if hitboxExpanderEnabled then
            updateHitboxes()
        end
    end,
})

local HitboxPartsDropdown = RageTab:CreateDropdown({
    Name = "Hitbox Parts",
    Options = {"Head", "HumanoidRootPart", "Both"},
    CurrentOption = "Head",
    Flag = "HitboxPartsDropdown",
    Callback = function(Option)
        if Option == "Both" then
            hitboxParts = {"Head", "HumanoidRootPart"}
        else
            hitboxParts = {Option}
        end
        
        if hitboxExpanderEnabled then
            updateHitboxes()
        end
    end,
})

RunService.RenderStepped:Connect(function()
    if hitboxExpanderEnabled then
        updateHitboxes()
    end
end)

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if hitboxExpanderEnabled then
            wait(0.5)
            updateHitboxes()
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    resetPlayerHitboxes(player)
end)

game:GetService("UserInputService").WindowFocused:Connect(function()
    if not hitboxExpanderEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local character = player.Character
                if character then
                    for _, partName in pairs(hitboxParts) do
                        local part = character:FindFirstChild(partName)
                        if part and originalSizes[player.Name..partName] then
                            part.Size = originalSizes[player.Name..partName]
                        end
                    end
                end
            end
        end
    end
end
		
local GodButton = RageTab:CreateButton({
	Name = "Toggle Godmode",
	Callback = function()
	local p=game:GetService("Players")
	local r=game:GetService("ReplicatedStorage")
	local s=p.LocalPlayer
	local f=r:WaitForChild("Events"):WaitForChild("FallDamage")
	local h=r:WaitForChild("Events"):WaitForChild("Heal")
	local c=s.Character or s.CharacterAdded:Wait()
	local a=c:WaitForChild("HumanoidRootPart")
	local b=c:WaitForChild("Humanoid")
	local d=a.CFrame--СЃРѕС…СЂР°РЅРёР» РїРѕР·Сѓ
	f.OnClientEvent:Connect(function() return nil end)
	c:BreakJoints()
	local e=s.CharacterAdded:Wait()
	local a2=e:WaitForChild("HumanoidRootPart")
	local b2=e:WaitForChild("Humanoid")
	h:FireServer(67)
	b2.Health=b2.MaxHealth
	a2.CFrame=d+Vector3.new(0,3,0)
	print'lol'
end,
})

-- legit | aimbot
local ToggleAimbot = false
local aimbotEnabled = false

local function getClosestTarget()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local targetPosition = player.Character.Head.Position
            local screenPosition, onScreen = workspace.CurrentCamera:WorldToScreenPoint(targetPosition)

            if onScreen then
                local distance = (Mouse.X - screenPosition.X)^2 + (Mouse.Y - screenPosition.Y)^2
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtTarget(target)
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local targetPosition = target.Character.Head.Position
        local camera = workspace.CurrentCamera
        local direction = (targetPosition - camera.CFrame.Position).unit
        camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + direction)
    end
end

RunService.RenderStepped:Connect(function()
if ToggleAimbot == true then
    if aimbotEnabled then
        local target = getClosestTarget()
        aimAtTarget(target)
	end
    end
end)

Mouse.Button2Down:Connect(function()
    aimbotEnabled = true
end)

Mouse.Button2Up:Connect(function()
    aimbotEnabled = false
end)

local AimToggle = LegitTab:CreateToggle({
    Name = "Toggle Aimbot",
    Callback = function()
        ToggleAimbot = not ToggleAimbot
    end,
})


--- Visuals | Chams
local espEnabled = false
local espHighlights = {}

local function createHighlight(player)
    if player == LocalPlayer then return nil end
    if not player.Character then return nil end
    
    local character = player.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return nil end

    if espHighlights[player.Name] then
        espHighlights[player.Name]:Destroy()
        espHighlights[player.Name] = nil
    end

    local highlight = Instance.new("Highlight")
    highlight.Name = "ESP_" .. player.Name
    highlight.FillColor = Color3.fromRGB(255, 0, 0)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = character

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Name_" .. player.Name
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = character
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 14
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.Parent = billboard

    return highlight
end

local function updateAllESP()
    if not espEnabled then return end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if not espHighlights[player.Name] then
                espHighlights[player.Name] = createHighlight(player)
            else
                if not espHighlights[player.Name] or not espHighlights[player.Name].Parent then
                    espHighlights[player.Name] = createHighlight(player)
                end
            end
        end
    end
end

local function removePlayerESP(playerName)
    if espHighlights[playerName] then
        espHighlights[playerName]:Destroy()
        espHighlights[playerName] = nil
    end
end

local espUpdateConnection
local function startESPUpdate()
    if espUpdateConnection then
        espUpdateConnection:Disconnect()
    end
    
    espUpdateConnection = RunService.Heartbeat:Connect(function()
        if espEnabled then
            updateAllESP()
        end
    end)
end

local function stopESPUpdate()
    if espUpdateConnection then
        espUpdateConnection:Disconnect()
        espUpdateConnection = nil
    end

    for playerName, highlight in pairs(espHighlights) do
        if highlight then
            highlight:Destroy()
        end
    end
    espHighlights = {}
end

local ESPToggle = VisualsTab:CreateToggle({
    Name = "Toggle Chams",
    Callback = function(Value)
        espEnabled = Value
        if Value then
            startESPUpdate()
            print("ESP: ON")
        else
            stopESPUpdate()
            print("ESP: OFF")
        end
    end,
})

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if espEnabled then
            wait(0.5)
            espHighlights[player.Name] = createHighlight(player)
        end
    end)
    
    player.CharacterRemoving:Connect(function()
        removePlayerESP(player.Name)
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    removePlayerESP(player.Name)
end)

local function setupRespawnDetection()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local function trackCharacter()
                local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.Died:Connect(function()
                        removePlayerESP(player.Name)
                        player.CharacterAdded:Wait()
                        wait(1)
                        if espEnabled then
                            espHighlights[player.Name] = createHighlight(player)
                        end
                    end)
                end
            end
            
            if player.Character then
                trackCharacter()
            end
            player.CharacterAdded:Connect(trackCharacter)
        end
    end
end

setupRespawnDetection()

if espEnabled then
    startESPUpdate()
end

---local | speedhack
local speedHackEnabled = false
local speedHackConnection = nil
local currentSpeed = 16
  
